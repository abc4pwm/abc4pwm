#!/usr/bin/env python

import logging
import argparse
from abc4pwm import classification , \
    cleandatabase_for_classification, \
    clustering, \
    plot_cluster_motifs, \
    quality_assessment, \
    visualize, \
    text_tfdb, \
    searching, \
    ensemble_learning, \
    format_conversion, \
    ensembling_compare, \
    pwm_representative_test




def setup_commandline_arguments():
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter,
     description="""==============Affinity Based Clustering for Position weight Matrices==============\n""",
     add_help=True, fromfile_prefix_chars="@",
     epilog="You should run the pipeline in the following order to generate all necessary files:\n"
            "1- 'cleandatabase_for_classification' :In the first step you should generate clean database to classify inputs files\n"
            "2- 'classification' :In this step classify files according to their DBD by adding labels\n"
            "3- 'clustering' :In the step apply clustering on output folder produced by step 2 \n"
            "4- 'quality_assessment' :This step calculates quality of clusters and remove uncertain quality pwms from clusters \n"
            "5- 'representative_motif' :This step calculates Familial Binding Profile and should be run before 'plot_clusters_motifs'\n"
            "6- 'plot_cluster_motifs' :This will plot the motifs inside cluster in along with the names in a pdf file. Also generate a text report'\n")
    try:
        subparsers = parser.add_subparsers(dest='command',
                                           help='Tasks available for using:')

        parser_clean_db = subparsers.add_parser('cleandatabase_for_classification', formatter_class=argparse.RawTextHelpFormatter,
                                            help='This module is use to create a uniform naming database of the input TFs along with their respective DBD information.',
                                            epilog='')

        parser_clean_db.add_argument("--pwm_files_directory",
                                     help="path to input files (position weight matrices) in "
                                                      ".mlp formate. Input file name should conatin TF name. i.e., "
                                          "TFName_**.mlp",
                                    type=str, metavar="FOLDER")
        parser_clean_db.add_argument("--read_new",
                                     help= "(Optional) Select 1 if you want a new updated read from "
                                                         "sources(internet Connection Required). Default 0",
                                     type=int, metavar="NUMBER", default=0)



        parser_classification_pwm = subparsers.add_parser('classification',
                                                formatter_class=argparse.RawTextHelpFormatter,
                                                help='This module is used to assign a DNA binding domain to the input '
                                                     'TF file.',
                                                epilog='')

        parser_classification_pwm.add_argument("--pwm_files_directory",
                                               help="path to input pwm files in .mlp format. Input file name should "
                                                    "conatin TF name. i.e., TFName_**.mlp",

                                     type=str, metavar="FOLDER")

        parser_classification_pwm.add_argument("--output_directory",
                                           help="path to output folder.",
                                           type=str, metavar="FOLDER")

        parser_classification_pwm.add_argument("--original_pwm_files_directory",
                                           help="This folder should contain a copy of input pwm files in "
                                                ".mlp format",
                                           type=str, metavar="FOLDER")
        parser_classification_pwm.add_argument("--load_new_db",
                                           help="(Optional) This parameter should be 1 if you want to download a new updated database"
                                                "from sources, Default  0",
                                           type=int, metavar="NUMBER", default=0)



        parser_clustering_pwms = subparsers.add_parser('clustering',
                                                formatter_class=argparse.RawTextHelpFormatter,
                                                help='Module for clustering',
                                                epilog='')

        parser_clustering_pwms.add_argument("--dbd_folders_directory",
                                            help="This folder should contain DBD folders with their pwms inside them. "
                                            "Output of classification should be this task input",
                                            type=str, metavar="FOLDER")
        parser_clustering_pwms.add_argument("--output_directory",
                                            help="This path will have the output files.",
                                            type=str, metavar="FOLDER")

        parser_clustering_pwms.add_argument("--path_to_txt",
                                            help="This path will have the summary out file.",
                                            type=str, metavar="FOLDER")

        parser_clustering_pwms.add_argument("--in_dbd",
                                               help="(Optional) This should be 0 if you want to cluster all pwms together with no DBD information. "
                                                    "1 by default ",
                                               type=int, metavar="NUMBER", default=1)
        parser_clustering_pwms.add_argument("--minimum_pwms_in_dbd",
                                            help="(Optional) minimum number of pwms in a dbd to be clustered"
                                                 "Default value is 5",
                                            type=int, metavar="NUMBER", default=5)

        parser_clustering_pwms.add_argument("--max_processors",
                                            help="(Optional) maximum number of processors for parallel processing"
                                                 "Default value is 5",
                                            type=int, metavar="NUMBER", default=5)
        parser_clustering_pwms.add_argument("--seed", help="Seed for random selection of cluster center. Input 1 to fix and reproduce results. Default Seed is 0. ",
                                              type=int, metavar="Number", default=0)
        parser_clustering_pwms.add_argument("--damp",
                                                 help="Damping factor (between 0.5 and 1) is the extent to which the current value is maintained relative to incoming values (weighted 1 - damping). "
                                                      "This in order to avoid numerical oscillations when updating these values (messages). ",
                                                 type=float, metavar="Number", default=0.5)
        parser_clustering_pwms.add_argument("--max_iter",
                                                 help="Maximum number of iterations. ",
                                                 type=int, metavar="Number", default=200)
        parser_clustering_pwms.add_argument("--convergence_iter",
                                                 help="Number of iterations with no change in the number of estimated clusters that stops the convergence.",
                                                 type=int, metavar="Number", default=15)
        parser_clustering_pwms.add_argument("--preference",
                                                 help="Preferences for each point - points with larger values of preferences are more likely to be chosen as exemplars. "
                                                      "The number of exemplars, ie of clusters, is influenced by the input preferences value. "
                                                      "If the preferences are not passed as arguments, they will be set to the median of the input similarities. ",
                                                 type=float or bytearray, metavar="Number", default=None)

        parser_representative_fbp = subparsers.add_parser('representative_motif',
                                                formatter_class=argparse.RawTextHelpFormatter,
                                                help='',
                                                epilog='')

        parser_representative_fbp.add_argument("--path_to_clusters",
                                               help="This folder should contain the clusters folders"
                                                    "If 'dbd' parameter is all then this path should point to folder"
                                                    "where all clustered dbds folders are stored ",
                                     type=str, metavar="FOLDER")
        parser_representative_fbp.add_argument("--dbd",
                                               help="Default value is 'selected'. Representative of clusters path"
                                                    "mentioned in --path_to_clusters parameter will be calculated.  "
                                                    "Write 'all' if representative calculation of all dbd and "
                                                    "all clusters is required.",
                                               type=str, metavar="string", default='selected')
        parser_representative_fbp.add_argument("--clusters",
                                           help="This argument should be cluster numbers as string "
                                                "For example, 0,1,2,3,4 if you want to plot these clusters"
                                                "write 'all' if you want to make representative for all clusters ",
                                           type=str, metavar="string", default='0')

        parser_representative_fbp.add_argument("--ic",
                                               help="(Optional) Information Content for trimming edges."
                                                    "Default value is 0 means no cutt off",
                                               type=float, metavar="NUMBER", default=0)
        parser_representative_fbp.add_argument("--best_match_initial_motif",
                                               help="(Optional) This should be 0 if initial motif to be random."
                                                    "1 is by default in which it will select a motif which resemble to "
                                                    "most of pwms in the list ",
                                               type=int, metavar="NUMBER", default=1
                                               )

        parser_representative_fbp.add_argument("--mean_threshold",
                                                help="(Optional) mean threshold for uncertain clusters"
                                                 "Default value is 0.80",
                                                type=float, metavar="NUMBER", default=0.77)

        parser_representative_fbp.add_argument("--z_score_threshold",
                                            help="(Optional) max negative threshold of zscore for similarity values "
                                                 "of pwm. Default value is -1.0",
                                            type=float, metavar="NUMBER", default=-1.0)

        parser_representative_fbp.add_argument("--top_occurrences",
                                            help="(Optional) This value corresponds to occurrence of a pwm less "
                                                 "than a threshold z-score"
                                                 "Value is between 0 to 1. Default value is 0.15",
                                            type=float, metavar="NUMBER", default=0.15)
        parser_representative_fbp.add_argument("--occurrences_threshold",
                                            help="(Optional) This value corresponds to threshold of occurrence from top"
                                                 " occurrences"
                                                 "Value is between 0 to 1. Default value is 0.05",
                                            type=float, metavar="NUMBER", default=0.05)

        parser_quality_cluster = subparsers.add_parser('quality_assessment',
                                                       formatter_class=argparse.RawTextHelpFormatter,
                                                       help='',
                                                       epilog='')

        parser_quality_cluster.add_argument("--dbd_folders_directory",
                                            help="This folder should contain clustered DBD folders. "
                                                 "Output of clustering should be this task input",
                                            type=str, metavar="FOLDER")
        parser_quality_cluster.add_argument("--out_path_for_qa_clusters",
                                            help="This folder should point to output folder"
                                            "where quality assessed clusters will be stored.",
                                            type=str, metavar="FOLDER")

        parser_quality_cluster.add_argument("--output_folder_for_text_report",
                                            help="Specify a folder where report in txt file will be stored.",
                                            type=str, metavar="FOLDER")
        parser_quality_cluster.add_argument("--output_path_for_quality_assessment_file",
                                            help="(Optional) folder where quality assessment .json file will be stored."
                                                 "Default, data/in/",
                                            type=str, metavar="FOLDER")


        parser_quality_cluster.add_argument("--load_new_assesment",
                                            help="(Optional)1 if you want to do new assessment,"
                                                 "0 if you want load existing assessment",
                                            type=int, metavar="NUMBER", default=0)

        parser_quality_cluster.add_argument("--minimum_pwms_in_dbd",
                                            help="(Optional) specify minimum numbers of pwms in DBD for processing quality. ",
                                            type=int, metavar="Number", default=5)

        parser_quality_cluster.add_argument("--mean_threshold",
                                            help="(Optional) mean threshold for uncertain clusters"
                                                 "Default value is 0.77",
                                            type=float, metavar="NUMBER", default=0.77)

        parser_quality_cluster.add_argument("--z_score_threshold",
                                    help="(Optional) max negative threshold of zscore for similarity values of pwm"
                                         "Default value is -1.0",
                                    type=float, metavar="NUMBER", default=-1.2)

        parser_quality_cluster.add_argument("--top_occurrences",
                                    help="(Optional) This value corresponds to occurrence of a pwm less than a threshold z-score"
                                         "Value is between 0 to 1. Default value is 0.15",
                                    type=float, metavar="NUMBER", default=0.05)
        parser_quality_cluster.add_argument("--occurrences_threshold",
                                            help="(Optional) This value corresponds to threshold of occurrence from top occurrences"
                                                 "Value is between 0 to 1. Default value is 0.05",
                                            type=float, metavar="NUMBER", default=0.05)


        parser_visualize = subparsers.add_parser('visualize',
                                                 formatter_class=argparse.RawTextHelpFormatter,
                                                 help='',
                                                 epilog='')
        parser_visualize.add_argument("--path_to_folder_of_assessment_file",
                                      help="folder path from where quality assessment file should be taken",
                                      type=str, metavar="FOLDER"
                                      )
        parser_visualize.add_argument("--path_to_folder_of_DBDs",
                                      help="this folder should contain clustered DBD folders",
                                      type=str, metavar="FOLDER"
                                      )
        parser_visualize.add_argument("--output_folder",
                                      help="folder where visualization output should be saved",
                                      type=str, metavar="FOLDER"
                                      )
        parser_visualize.add_argument("--dbd_for_plot",
                                      help="path of dbd which is needed to be visualized."
                                           "Write 'all' if you want to plot all dbds",
                                      type=str, metavar="FOLDER"
                                      )
        parser_visualize.add_argument("--task",
                                         help="(Optional) Specify visualization task"
                                              "For example, boxplot, pichart, etc",
                                         type=str, metavar="string", default='boxplot')

        parser_plot_cluster = subparsers.add_parser('plot_cluster_motifs',
                                                       formatter_class=argparse.RawTextHelpFormatter,
                                                       help='run representative motif task before running this task',
                                                       epilog='')

        parser_plot_cluster.add_argument("--path_to_clusters",
                                         help="This folder should contain the clusters folders"
                                              "If 'dbd' parameter is all then this path should point to folder"
                                              "where all clustered dbds folders are stored ",
                                         type=str, metavar="FOLDER")
        parser_plot_cluster.add_argument("--output_folder_pdfs",
                                            help="Specify folder for storing plots in pdfs",
                                            type=str, metavar="FOLDER")

        parser_plot_cluster.add_argument("--clusters",
                                           help="This arguement should be cluster numbers as string "
                                                "For example, 0,1,2,3,4 if you want to plot these clusters"
                                                "write 'all' if you want to plot all clusters ",
                                           type=str, metavar="string", default='0')
        parser_plot_cluster.add_argument("--dbd",
                                               help="Default value is 'selected'. Clusters path"
                                                    "mentioned in --path_to_clusters parameter will be printed  "
                                                    "Write 'all' if plotting of all dbd and "
                                                    "all clusters is required.",
                                               type=str, metavar="string", default='selected')



        parser_textTFDB = subparsers.add_parser('text_tfdb',
                                                       formatter_class=argparse.RawTextHelpFormatter,
                                                       help='',
                                                       epilog='')

        parser_textTFDB.add_argument("--pwm_files_directory", help="This folder should contain the input pwm files in "
                                                      ". mlp formate ",
                                 type=str, metavar="FOLDER")
        parser_textTFDB.add_argument("--output_directory", help="This folder should to output folder. "
                                                                       "Boxplot will go to this folder",
                                            type=str, metavar="FOLDER")

        parser_searching = subparsers.add_parser('searching',
                                                formatter_class=argparse.RawTextHelpFormatter,
                                                 help='',
                                                 epilog='')
        parser_searching.add_argument('--pwm',
                                      help="position weight matrix file (motif) which you want to search. .mlp format",
                                      metavar=". mlp file")
        parser_searching.add_argument('--db_path',
                                     help="path to clustered dbds according to the hierarchy of abc4pwm."
                                          "if db_type=list then then this paramter should be list of pwms, against "
                                          "whcih you are searching the pwm",
                                     metavar="path or list")
        parser_searching.add_argument("--output_directory", help="This folder should to output folder. "
                                                                "search_result.pdf output file will be stored here.",
                                     type=str, metavar="FOLDER")
        parser_searching.add_argument('--tf_name',
                                      help="(Optional) If you want to search specific tf in a folder then use this parameter",
                                      metavar="string", default='')
        parser_searching.add_argument('--db_type',
                              help="(Optional) If database for comparison is folder hierarchy like abs4pwm then this will"
                                   "be db_type=path. Write list if providing list of pwms for comparison",
                              metavar="string", default='path')

        parser_searching.add_argument('--db_format',
                                      help="(Optional) If database for comparison have format, please mention."
                                           "Supported formats are abc4pwm, Tranfac, Jaspar. default is abc4pwm",
                                      metavar="string", default='abc4pwm')
        parser_searching.add_argument('--top_n',
                                      help="(Optional) Number of top matches from the database. Default 5",
                                      type=int,  metavar="NUMBER", default=5)
        parser_searching.add_argument('--input_count',
                                      help="(Optional) 1 if input file contains values in counts",
                                      type=int, metavar="NUMBER", default=0)
        parser_searching.add_argument('--db_count',
                                      help="1 if database file contains values in counts",
                                      type=int, metavar="NUMBER", default=0)
        parser_searching.add_argument('--db_file_type',
                                      help="mention the extension of file type. e.g., .mlp, .txt",
                                      type=str, metavar="String", default='.mlp')
        parser_searching.add_argument('--input_file_type',
                                      help="mention the extension of file type. e.g., .mlp, .txt",
                                      type=str, metavar="String", default='.mlp')
        parser_searching.add_argument('--input_prob',
                                      help="(Optional) 1 if input file contains values in probabilities",
                                      type=int, metavar="Number", default=0)
        parser_searching.add_argument('--db_prob',
                                      help="(Optional) 1 if databas file contains values in probabilities",
                                      type=int, metavar="Number", default=0)

        parser_conversion = subparsers.add_parser('conversion',
                                                formatter_class=argparse.RawTextHelpFormatter,
                                                 help='',
                                                 epilog='')
        parser_conversion.add_argument("--pwm_files_directory", help="This folder should contain the input pwm files in "
                                                      ". mlp formate  which you want to convert",
                                 type=str, metavar="FOLDER")
        parser_conversion.add_argument("--in2out",
                                       help="Specify conversion like the following. \n" \
                                        "--in2out 'abc4pwm2transfac' \n " \
                                        "--in2out 'transfac2abc4pwm'",
                                         type=str, metavar="string", default='boxplot')
        parser_conversion.add_argument("--output_folder",
                                      help="folder where converted files should be saved",
                                      type=str, metavar="FOLDER")

        parser_ensemble_learning = subparsers.add_parser('ensemble_learning',
                                                         formatter_class=argparse.RawTextHelpFormatter,
                                                         help='',
                                                         epilog='')
        parser_ensemble_learning.add_argument("--opt_dependence",
                                              help="Define dependence, Default is 0.",
                                              type=int, metavar="Number", default=0)
        parser_ensemble_learning.add_argument("--numP", help="number of times random selections will be done. Default is 15 ",
                                              type=int, metavar="Number", default=15)
        parser_ensemble_learning.add_argument("--opt_numOfWeakReads", help="number of weak read if any. Default 0. ",
                                              type=int, metavar="Number", default=0)
        parser_ensemble_learning.add_argument("--number_of_genes", help="number of genes to be selected from input. Default is 200 ",
                                              type=int, metavar="Number", default=200)
        parser_ensemble_learning.add_argument("--expFile", help="Strong Expression file path ",
                                              type=str, metavar="File path", default='demo_in/demo_swi4_0.5Kseq_cacgaaaa_500.txt')
        parser_ensemble_learning.add_argument("--opt_weak_expFile", help="Weak expression file path. ",
                                              type=str, metavar="File path", default='')
        parser_ensemble_learning.add_argument("--opt_seqFile", help="Strong sequence file path. ",
                                              type=str, metavar="File path", default='demo_in/demo_swi4_0.5Kseq_cacgaaaa_500.fa')
        parser_ensemble_learning.add_argument("--opt_out", help="output folder path.  ",
                                              type=str, metavar="File path. ", default='demo_out_ensemble/swi4/')
        parser_ensemble_learning.add_argument("--opt_loops", help="Number of loops to repeat calculations. Default is 3.",
                                              type=int, metavar="Number", default=3)
        parser_ensemble_learning.add_argument("--opt_min_L", help="Minimum length for predicted pwm (motif), Default is 9.",
                                              type=int, metavar="Number", default=9)
        parser_ensemble_learning.add_argument("--opt_max_L", help="Maximum length for predicted pwm (motif). Default is 9. ",
                                              type=int, metavar="Number", default=9)
        parser_ensemble_learning.add_argument("--opt_iteration", help="Number of iterations. Default is 500. ",
                                      type=int, metavar="Number", default=500)
        parser_ensemble_learning.add_argument("--opt_p_value", help="p value. Default is 0.0001 ",
                                              type=float, metavar="float", default=0.0001)
        parser_ensemble_learning.add_argument("--opt_strand", help="Strand. Default is 0 ",
                                              type=int, metavar="Number", default=0)
        parser_ensemble_learning.add_argument("--opt_normalization", help="Normalization value. Default is 2.",
                                              type=int, metavar="Number", default=2)
        parser_ensemble_learning.add_argument("--max_processors", help="Define maximum number of processors for parallel computing. Default is mp.cpu_count()",
                                              type=int, metavar="Number")
        parser_ensemble_learning.add_argument("--seed", help="Seed for random selection. Default seed is 0. ",
                                              type=int, metavar="Number", default=0)


        parser_ensemble_investigate = subparsers.add_parser('ensemble_investigate',
                                                         formatter_class=argparse.RawTextHelpFormatter,
                                                         help='',
                                                         epilog='')

        parser_ensemble_investigate.add_argument('--path_to_predicted_files',
                                      help="Folder which contain predicted files.",
                                      metavar=". mlp file")
        parser_ensemble_investigate.add_argument('--db_folder',
                                      help="path to clustered dbds according to the hierarchy of abc4pwm."
                                           "if db_type=list then then this paramter should be list of pwms, against "
                                           "whcih you are searching the pwm",
                                      metavar="path or list")
        parser_ensemble_investigate.add_argument("--dst_for_bad_pwms",
                                                 help="destination folder for storing bad pwms ",
                                                 metavar="path")
        parser_ensemble_investigate.add_argument("--output_folder", help="This folder should to output folder. "
                                                                 "search_result.pdf output file will be stored here.",
                                      type=str, metavar="FOLDER")
        parser_ensemble_investigate.add_argument('--tf_name',
                                      help="(Optional) If you want to search specific tf in a folder then use this parameter",
                                      metavar="string", default='')
        parser_ensemble_investigate.add_argument('--db_type',
                                      help="(Optional) If database for comparison is folder hierarchy like abs4pwm then this will"
                                           "be db_type=path. Write list if providing list of pwms for comparison",
                                      metavar="string", default='folder')
        parser_ensemble_investigate.add_argument("--mean_threshold",
                                               help="(Optional) mean threshold for uncertain clusters for quality assesment step"
                                                    "Default value is 0.80",
                                               type=float, metavar="NUMBER", default=0.77)

        parser_ensemble_investigate.add_argument("--z_score_threshold",
                                               help="(Optional) max negative threshold of zscore for similarity values "
                                                    "of pwm for quality assesment step. Default value is -1.0",
                                               type=float, metavar="NUMBER", default=-1.0)

        parser_ensemble_investigate.add_argument("--top_occurrences",
                                               help="(Optional) This value corresponds to occurrence of a pwm less "
                                                    "than a threshold z-score for quality assesment step"
                                                    "Value is between 0 to 1. Default value is 0.15",
                                               type=float, metavar="NUMBER", default=0.15)
        parser_ensemble_investigate.add_argument("--occurrences_threshold",
                                               help="(Optional) This value corresponds to threshold of occurrence from top"
                                                    " occurrences for quality assesment step"
                                                    "Value is between 0 to 1. Default value is 0.05",
                                               type=float, metavar="NUMBER", default=0.05)
        parser_ensemble_investigate.add_argument("--ic_for_rep",
                                               help="(Optional) Information Content for trimming edges."
                                                    "Default value is 0 means no cutt off.",
                                               type=float, metavar="NUMBER", default=0)
        parser_ensemble_investigate.add_argument("--top_n",
                                                 help="Specify how many top matches from database is required. Default 2",
                                                 default=2)
        parser_ensemble_investigate.add_argument("--min_pwms_in_cluster",
                                                 help="Number of minimum acceptable pwms in a cluster made from predicted pwms. Default 3",
                                                 default=3)
        parser_ensemble_investigate.add_argument('--db_format',
                                      help="(Optional) If database for comparison have format, please mention."
                                           "Supported formats are abc4pwm, Tranfac, Jaspar. default is abc4pwm",
                                      metavar="string", default='abc4pwm')
        parser_ensemble_investigate.add_argument('--input_count',
                                      help="(Optional) 1 if input file contains values in counts",
                                      type=int, metavar="NUMBER", default=1)
        parser_ensemble_investigate.add_argument('--db_count',
                                      help="1 if database file contains values in counts",
                                      type=int, metavar="NUMBER", default=0)
        parser_ensemble_investigate.add_argument('--db_file_type',
                                      help="mention the extension of file type. e.g., .mlp, .txt",
                                      type=str, metavar="String", default='.txt')
        parser_ensemble_investigate.add_argument('--input_file_type',
                                      help="mention the extension of file type. e.g., .mlp, .txt",
                                      type=str, metavar="String", default='.mlp')
        parser_ensemble_investigate.add_argument('--input_prob',
                                      help="(Optional) 1 if input file contains values in probabilities",
                                      type=int, metavar="Number", default=0)
        parser_ensemble_investigate.add_argument('--db_prob',
                                                 help="(Optional) 1 if database file contains values in probabilities",
                                                 type=int, metavar="Number", default=1)
        parser_ensemble_investigate.add_argument('--qa',
                                                 help="(Optional) 1 if quality assesment is needed.",
                                                 type=int, metavar="Number", default=0)
        parser_ensemble_investigate.add_argument("--seed",
                                                 help="Seed for random selection of cluster center. Input 1 to fix clusters. Default Seed is 0. ",
                                                 type=int, metavar="Number", default=0)
        parser_ensemble_investigate.add_argument("--damp",
                                                 help="Damping factor (between 0.5 and 1) is the extent to which the current value is maintained relative to incoming values (weighted 1 - damping). "
                                                      "This in order to avoid numerical oscillations when updating these values (messages). ",
                                                 type=float, metavar="Number", default=0.5)
        parser_ensemble_investigate.add_argument("--max_iter",
                                                 help="Maximum number of iterations. ",
                                                 type=int, metavar="Number", default=200)
        parser_ensemble_investigate.add_argument("--convergence_iter",
                                                 help="Number of iterations with no change in the number of estimated clusters that stops the convergence.",
                                                 type=int, metavar="Number", default=15)
        parser_ensemble_investigate.add_argument("--preference",
                                                 help="Preferences for each point - points with larger values of preferences are more likely to be chosen as exemplars. "
                                                      "The number of exemplars, ie of clusters, is influenced by the input preferences value. "
                                                      "If the preferences are not passed as arguments, they will be set to the median of the input similarities. ",
                                                 type=float or bytearray, metavar="Number", default=None)

        ################################################################################################################



    except IOError:
        print("Command line argument error:")
        exit(1)
    return parser.parse_args()


if __name__ == "__main__":
    args = setup_commandline_arguments()


    if args.command == 'cleandatabase_for_classification':
        cleandatabase_for_classification.cleanTFDB(args.pwm_files_directory,
                                                   args.read_new)

    elif args.command == 'classification':
        classification.ClassificationPwm(args.pwm_files_directory,
                                         args.output_directory,
                                         args.original_pwm_files_directory,
                                         args.load_new_db)

    elif args.command == 'clustering':
        clustering.ClusteringPwm(args.dbd_folders_directory,
                                 args.output_directory,
                                 args.path_to_txt,
                                 args.in_dbd,
                                 args.minimum_pwms_in_dbd,
                                 args.max_processors,
                                 args.seed,
                                 args.damp,
                                 args.max_iter,
                                 args.convergence_iter,
                                 args.preference)

    elif args.command == 'quality_assessment':

        quality_assessment.ClusterQuality(args.dbd_folders_directory,
                                          args.out_path_for_qa_clusters,
                                          args.output_folder_for_text_report,
                                          args.output_path_for_quality_assessment_file,
                                          args.load_new_assesment,
                                          args.minimum_pwms_in_dbd,
                                          args.mean_threshold,
                                          args.z_score_threshold,
                                          args.top_occurrences,
                                          args.occurrences_threshold
                                          )
    elif args.command == 'representative_motif':
        pwm_representative_test.make_representative_pwm(args.path_to_clusters,
                                                        args.dbd,
                                                        args.clusters,
                                                        args.ic,
                                                        args.best_match_initial_motif,
                                                        args.mean_threshold,
                                                        args.z_score_threshold,
                                                        args.top_occurrences,
                                                        args.occurrences_threshold
                                                        )
    elif args.command == 'visualize':
        visualize.Visualize(args.path_to_folder_of_assessment_file,
                            args.path_to_folder_of_DBDs,
                            args.output_folder,
                            args.dbd_for_plot,
                            args.task)

    elif args.command == 'plot_cluster_motifs':
        plot_cluster_motifs.plottingCluster(args.path_to_clusters,
                                            args.output_folder_pdfs,
                                            args.clusters,
                                            args.dbd)

    elif args.command == 'text_tfdb':
        text_tfdb.make_txt_of_clean_databse(args.pwm_files_directory, args.output_directory)


    elif args.command == 'searching':

        searching.searching(args.pwm,
                            args.db_path,
                            args.output_directory,
                            args.tf_name,
                            args.db_type,
                            args.db_format,
                            args.top_n,
                            args.input_count,
                            args.db_count,
                            args.db_file_type,
                            args.input_file_type,
                            args.input_prob,
                            args.db_prob)
    elif args.command == 'ensemble_learning':
        ensemble_learning.EnsembleLearning(
            args.opt_dependence,
            args.numP,
            args.opt_numOfWeakReads,
            args.number_of_genes,
            args.expFile,
            args.opt_weak_expFile,
            args.opt_seqFile,
            args.opt_out,
            args.opt_loops,
            args.opt_min_L,
            args.opt_max_L,
            args.opt_iteration,
            args.opt_p_value,
            args.opt_strand,
            args.opt_normalization,
            args.max_processors,
            args.seed)
    elif args.command == 'ensemble_investigate':
        ensembling_compare.PredictedCompare(
            args.path_to_predicted_files,
            args.output_folder,
            args.db_folder,
            args.dst_for_bad_pwms,
            args.min_pwms_in_cluster,
            args.mean_threshold,
            args.z_score_threshold,
            args.top_occurrences,
            args.occurrences_threshold,
            args.ic_for_rep,
            args.top_n,
            args.db_type,
            args.input_count,
            args.db_count,
            args.db_file_type,
            args.input_file_type,
            args.input_prob,
            args.db_prob,
            args.tf_name,
            args.qa,
            args.seed,
            args.damp,
            args.max_iter,
            args.convergence_iter,
            args.preference)



    elif args.command == 'conversion':
        format_conversion.Conversion(args.pwm_files_directory,
                            args.in2out,
                            args.output_folder)

    else:
        logging.error('Unknown step name you can choose only from clean_database_for_classfication', 'classfication'
                      'clustering, quality_assessment, representative_motif, plot_cluster_motifs, text_tfdb, ensemble_learning, searching, ensemble_investigate, visualize')
        exit(1)

    exit(0)
